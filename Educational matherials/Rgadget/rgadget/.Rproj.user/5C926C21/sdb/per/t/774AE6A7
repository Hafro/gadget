{
    "contents" : "##' Rgadget is the driver function for the ecosystem simulation. It takes a\n##' gadget options list, where all parameters of the simulation are set, as\n##' input and runs the simulation for a set period of time (the length of the\n##' timesteps and number of observations (years) are also defined in gadget\n##' options).\n##'\n##' The Rgadget simulator replicates some of the more commonly used features of\n##' Gadget, with use of some of these features optional. The most complex model\n##' possible consists of two substocks, with the younger substock optionally\n##' maturing into the older substock at a given age and timestep, ie the\n##' maturation process is not modelled. Both substocks are subject to growth\n##' and natural mortality and live on a number of areas. Two fleets are possible, eg\n##' one representing the commercial fleet and the other an annual survey, with\n##' the timesteps on which these fleets operate optional. There can be\n##' migration between the areas. The mature substock can also predate upon the\n##' immature stock. As with Gadget, the fleets are modelled as predators. The\n##' order in which the population processes are modelled on each timestep is\n##' identical to that in Gadget.\n##' \n##' As Gadget is a forward simulation model, it is started with an initial\n##' population. The length distribution of each age group of the population\n##' is assumed to be normally distributed with a given mean and standard\n##' deviation (specified by the user). The youngest age group in each year\n##' is entered into the population in a similar manner.\n##' Fleets are modelled as predators, as in Gadget, and operate on some or all\n##' areas and at some or all timesteps which are defined by the user.\n##' Consumption (predation or harvesting) implemented through length based\n##' suitability functions of the form:\n##'  \\deqn{S_{pred,prey}(L,l) = \\frac{\\delta}{1+e^{-\\alpha-\\beta l-\\gamma L}}}\n##' where of l is the prey length and L predator length. For fleets L should be\n##' irrelevant and therefore \\eqn{\\gamma = 0}{gamma  = 0} for fleets.\n##' \n##' Maturation from stock A to stock B is modelled by moving the oldest\n##' agegroup of A into with the age increasing if done on the last timestep\n##' of the year. This replicates the Gadget process \\emph{doesmove}.\n##'\n##' Growth follows a beta-binomial distribution with mean update length as\n##' stipulated by the von Bertanlanffy curve.\n##' \n##' The order of calculations is the same as in Gadget and is as follows:\n##'\n##' 1. Migration between areas\n##' \n##' 2. Consumption, including catch by the fleets\n##' \n##' 3. Natural mortality\n##' \n##' 4. Growth\n##' \n##' 5. Recruitment\n##' \n##' 6. Remove the stock, here immature, that will move\n##' \n##' 7. Increase the age\n##' \n##' 8. Replace the stock, here to the mature, that has moved and increase the age. \n##' @title Rgadget\n##' @param opt gadget options list, as defined by 'gadget.options'\n##' @return a list of arrays:\n##' \\item{Rec}{Recruits for all years}\n##' \\item{immStart}{Initial starting population for the immature stock age 2 and older}\n##' \\item{matStart}{Initial starting population for the mature stock age 2 and older}\n##' \\item{immNumRec}{Immature stock population for all timesteps, areas, ages and lengths}\n##' \\item{matNumRec}{Mature stock population for all timesteps, areas, ages and lengths}\n##' \\item{immCsurv}{Survey catches of the immature stock}\n##' \\item{matCsurv}{Survey catches of the mature stock}\n##' \\item{immCcomm}{Commercial catches of the immature stock}\n##' \\item{matCcomm}{Commercial catches of the mature stock}\n##' \\item{Eat}{Amount consumed of immatures by matures}\n##' \\item{GrowthProb}{Growthprobability matrix}\n##' \\item{immMort}{Natural mortality for the immature stock}\n##' \\item{matMort}{Natural mortality for the mature stock}\n##' \\item{opt}{Gadget options list used in the simulation}\n##'  @author Bjarki Thor Elvarsson, Asta Jenny Sigurdardottir and Elinborg Ingunn Olafsdottir\n##' @examples\n##' opt <- gadget.options()\n##' sim <- Rgadget(sim)\ngadget.simulate <- function(opt=gadget.options()){\n  ## initialize the necessary variables  \n  opt <- derivedOptions(opt)\n  ## what areas are commercially exploited\n  commAreas <- 1:opt$numofareas %in% opt$doescatchcomm\n  ## define survey areas \n  surveyAreas <- 1:opt$numofareas %in% opt$doescatchsurv\n\n################################\n#\n# The stocks\n# preN(k)=[N_{i,1,j}] is a matrix where immN(k)_{i,1,j} 7is the number\n# of recruits in lengthgroup i at timestep j, area k\n#  stocks <- array(0,c(length(opt$stocks),\n#                      opt$\n  immNumRec <- array(0,c(opt$numofareas,\n                         opt$numoflgroups,\n                         opt$immmax,\n                         (opt$numobs*opt$numoftimesteps)))\n  dimnames(immNumRec) <- list(area=1:opt$numofareas,\n                              length=opt$minlen:(opt$maxlen-1),\n                              age=opt$immminage:opt$immmaxage,\n                              time=paste(sprintf('Year_%s',rep(1:opt$numobs,\n                                each=opt$numoftimesteps)\n                                ),\n                                sprintf('Step_%s',rep(1:opt$numoftimesteps,\n                                                      opt$numobs)),\n                                sep='_'))\n  matNumRec <- array(0,c(opt$numofareas,\n                         opt$numoflgroups,\n                         opt$matmax,\n                         (opt$numobs*opt$numoftimesteps)))\n  dimnames(matNumRec) <- list(area=1:opt$numofareas,\n                              length=opt$minlen:(opt$maxlen-1),\n                              age=opt$matminage:opt$matmaxage,\n                              time=paste(sprintf('Year_%s',rep(1:opt$numobs,\n                                each=opt$numoftimesteps)\n                                ),\n                                sprintf('Step_%s',rep(1:opt$numoftimesteps,\n                                                      opt$numobs)),\n                                sep='_'))\n\n################################\n#\n# Calculates natural mortality per timestep\n\n#preM is a survival matrix, same in both areas\n  M <- diag(exp(-opt$mort*opt$dt))\n  immMort <- M[opt$immminage:opt$immmaxage,\n               opt$immminage:opt$immmaxage]\n  matMort <- M[opt$matminage:opt$matmaxage,\n               opt$matminage:opt$matmaxage]\n\n################################\n#\n# Defines the catch matrices\n  catch.switch<- opt$doescatchcomm+opt$doescatchsurv\n  \n  if(sum(catch.switch)>0)\n    {\n      immCcomm <- array(0,c(opt$numofareas,\n                            opt$numoflgroups,\n                            opt$immmax,\n                            (opt$numobs*opt$numoftimesteps)))\n      dimnames(immCcomm) <- dimnames(immNumRec)\n      matCcomm <- array(0,c(opt$numofareas,\n                            opt$numoflgroups,\n                            opt$matmax,\n                            (opt$numobs*opt$numoftimesteps)))\n      dimnames(matCcomm) <- dimnames(matNumRec)\n      immCsurv <- array(0,c(opt$numofareas,\n                            opt$numoflgroups,\n                            opt$immmax,\n                            (opt$numobs*opt$numoftimesteps)))\n      dimnames(immCsurv) <- dimnames(immNumRec)\n      matCsurv <- array(0,c(opt$numofareas,\n                            opt$numoflgroups,\n                            opt$matmax,\n                            (opt$numobs*opt$numoftimesteps)))\n      dimnames(matCsurv) <- dimnames(matNumRec)\n    }\n\n\n#################################\n#\n# Predation\n#\n\n# The number eaten of immature by mature, the default is zero\n  Eat <- array(0,c(opt$numofareas,\n                   opt$numoflgroups,\n                   opt$immmax,\n                   opt$numobs*opt$numoftimesteps))\n  dimnames(Eat) <- dimnames(immNumRec)\n  \n#################################\n\n# Assume we have one pseudo stock which splits between the 2\n# areas in the portion probarea1 in area 1 and\n# (1-probarea1) in area 2.\n  Start<-firststep(opt$n,\n                   opt$mu,\n                   opt$sigma,\n                   opt$l,\n                   opt$z,\n                   opt$numofareas,\n                   opt$probarea,\n                   opt$minage,\n                   opt$maxage)\n  \n# preStart[i,j] is number in pseudo stock at the beginning of timestep 1,\n# (1 year olds are not included). We use Start to make initial\n# mature and immature stock such that the amount of i year old in the\n# mature/immmature stock is the same as in the pseudo stock.\n  immStart <- Start[,,(opt$immminage+1):opt$immmaxage]\n  matStart <- Start[,,(opt$matminage:opt$matmaxage)]\n  if(opt$numofareas==1){\n    ## ugly hack because of destroyed array dimension\n    dimnames(immStart) -> tmp\n    dim(immStart) <- c(1,dim(immStart))\n    dimnames(immStart) <- list(area=1,length=tmp[[1]],age=tmp[[2]])\n    dimnames(matStart) -> tmp\n    dim(matStart) <- c(1,dim(matStart))\n    dimnames(matStart) <- list(area=1,length=tmp[[1]],age=tmp[[2]])\n  }\n#Matrix of length divided recruits\n  Rec <- recruits(opt$n,opt$mu[opt$immminage],opt$sigma[opt$immminage],\n                  opt$l,opt$numofareas, opt$probarea,\n                  opt$numobs,opt$numoftimesteps)\n\n#G[i,j] is the probability of going from lengthgroup i to lengthgroup j\n#Same in both areas\n  G <- growthprob(opt$lt,\n                  opt$beta,\n                  opt$lsup,\n                  opt$k,\n                  opt$dt,\n                  opt$lengthgrouplen,\n                  opt$binn)\n\n####################################\n#  Calculations for all timesteps  #\n####################################\n  for(i in 1:(opt$numobs*opt$numoftimesteps))\n    {\n      num<-i%%opt$numoftimesteps\n      if(num==0)\n        num <- opt$numoftimesteps\n      if(num!=1){      ############## if we are not in timestep 1  #########\n        immNumRec[,,,i] <- immNumRec[,,,i-1]\n        matNumRec[,,,i] <- matNumRec[,,,i-1]\n      } else if(i==1){ ### we have a special update in the 1st timestep ###\n        immNumRec[,,-1,1] <- immStart\n        matNumRec[,,,1] <- matStart\n      } else { ###### if we are in timestep 1 we have to update age ######\n        \n    #############\n    # Age update\n    # NOTE this is the last step of the\n    # calculations done in previous timestep\n\n    # Update age for immature upto age immmaxage-1\n          immNumRec[,,-1,i] <- immNumRec[,,-opt$immmax,i-1]\n    # Update age for mature\n          matNumRec[,,-1,i] <- matNumRec[,,-opt$matmax,i-1]\n    # Adding up the maxage ones\n           matNumRec[,,opt$matmax,i] <-\n             matNumRec[,,opt$matmax,i] + matNumRec[,,opt$matmax,i-1]\n\n          if(opt$doesmove==1){\n      ## Adding the ones which have moved between stocks\n            matimmdiff <- opt$immmaxage-opt$matminage+2\n            matNumRec[,,matimmdiff,i] <-\n              matNumRec[,,matimmdiff,i]+immNumRec[,,opt$immmax,i-1]\n          } else {\n      ## if they don't move between stocks we have\n      ## a + group for the immmaxage ones\n            immNumRec[,,opt$immmax,i] <-\n              immNumRec[,,opt$immmax,i]+immNumRec[,,opt$immmax,i-1]\n          }\n        }\n      ############\n      # Migration Assume only two areas atm\n      if(opt$doesmigrateimm==1){\n        immNumRec[,,,i] <- migrate(immNumRec[,,,i],opt$immMigration[,,num])\n#        immTemp<-migrate(immNumRec[1,,,i],immNumRec[2,,,i],\n#                         num,P=migrationProb(opt=opt),opt=opt)\n#        immNumRec[1,,,i] <- immTemp[,,1]\n#        immNumRec[2,,,i] <- immTemp[,,2]\n      }\n      if(opt$doesmigratemat==1){\n        matNumRec[,,,i] <- migrate(matNumRec[,,,i],opt$matMigration[,,num])\n#        matTemp<-migrate(matNumRec[1,,,i],matNumRec[2,,,i],\n#                         num,P=migrationProb(opt=opt),opt=opt)\n#        matNumRec[1,,,i] <- matTemp[,,1]\n#        matNumRec[2,,,i] <- matTemp[,,2]\n      }\n\n\n  ############\n  # Consumption calculations\n      if(opt$doeseat==1){\n          Eat[,,,i] <- eat(immNumRec,matNumRec,i,opt)\n        }\n      \n  ############\n  # Catch calculations\n      if(num %in% opt$commstep){\n        if(sum(opt$doescatchcomm) > 0)\n          {\n            if('imm' %in% opt$comm.catches){\n              immCcomm[commAreas,,,i] <-\n                catch(immNumRec[commAreas,,,i],\n                      i,\n                      opt$Fycomm,\n                      opt$salphacomm,\n                      opt$sbetacomm,\n                      opt$numoftimesteps,\n                      opt$numobs,\n                      opt$lt)\n            }\n            if('mat' %in% opt$comm.catches){\n              matCcomm[commAreas,,,i] <-\n                catch(matNumRec[commAreas,,,i],\n                      i,\n                      opt$Fycomm,\n                      opt$salphacomm,\n                      opt$sbetacomm,\n                      opt$numoftimesteps,\n                      opt$numobs,\n                      opt$lt)\n            }\n          }\n      }\n      if(num %in% opt$survstep) \n        {\n          if(sum(opt$doescatchsurv) > 0)\n            {\n              if('imm' %in% opt$surv.catches){\n                immCsurv[surveyAreas,,,i] <-\n                  catch(immNumRec[surveyAreas,,,i],\n                        i,\n                        opt$Fysurv,\n                        opt$salphasurv,\n                        opt$sbetasurv,\n                        1,\n                        opt$numobs,\n                        opt$lt)\n              }\n              if('mat' %in% opt$surv.catches){\n                matCsurv[surveyAreas,,,i] <-\n                  catch(matNumRec[surveyAreas,,,i],\n                        i,\n                        opt$Fysurv,\n                        opt$salphasurv,\n                        opt$sbetasurv,\n                        1,\n                        opt$numobs,\n                        opt$lt)\n              }\n            }\n        }\n\n  #############\n  # Overconsumption check\n      tempimmC<-adjustconsumption(C=immCcomm[,,,i],\n                                  S=immCsurv[,,,i],\n                                  E=Eat[,,,i],\n                                  N=immNumRec[,,,i],\n                                  opt$maxratioconsumed,\n                                  opt$numofareas)\n      tempmatC<-adjustconsumption(C=matCcomm[,,,i],\n                                  S=matCsurv[,,,i],\n                                  ,\n                                  N=matNumRec[,,,i],\n                                  opt$maxratioconsumed,\n                                  opt$numofareas)\n\n  #############\n  # Subtract Consumption from stock\n      if(opt$doeseat==1)\n        {\n          immNumRec[,,,i] <- immNumRec[,,,i] - tempimmC$E[,,]\n        }\n\n  ##########\n  # Subtract Catch from stock\n      if(num==opt$survstep) # only have survey in one timestep of the year\n        {\n          surveyAreas <- 1:opt$numofareas %in% opt$doescatchsurv\n          immNumRec[surveyAreas,,,i] <- immNumRec[surveyAreas,,,i]-\n            tempimmC$S[surveyAreas,,]\n          matNumRec[surveyAreas,,,i] <- matNumRec[surveyAreas,,,i]-\n            tempmatC$S[surveyAreas,,]\n        }\n      immNumRec[commAreas,,,i] <- immNumRec[commAreas,,,i]-\n        tempimmC$C[commAreas,,]\n      matNumRec[commAreas,,,i] <- matNumRec[commAreas,,,i]-\n        tempmatC$C[commAreas,,]\n\n\n\n  ###########\n  # Length update and natural mortality\n      for(area in 1:opt$numofarea){\n        immNumRec[area,,,i] <- t(G)%*%immNumRec[area,,,i]%*%immMort\n        matNumRec[area,,,i] <- t(G)%*%matNumRec[area,,,i]%*%matMort\n      }\n  ###########\n  # Recruits\n      if(opt$doesmove!=1){\n        matNumRec[,,1,i]<-matNumRec[,,1,i]+Rec[,,i]\n      }\n      immNumRec[,,1,i]<-immNumRec[,,1,i]+Rec[,,i]\n    }\n\n  \n  sim <- list(Rec=Rec,\n              immStart=immStart,\n              matStart=matStart,\n              immNumRec=immNumRec,\n              matNumRec=matNumRec,\n              immCsurv=immCsurv,\n              matCsurv=matCsurv,\n              immCcomm=immCcomm,\n              matCcomm=matCcomm,\n              Eat=Eat,\n              GrowthProb=G,\n              immMort=immMort,\n              matMort=matMort,\n              opt=opt)\n  class(sim) <- c('gadget.sim',class(sim))\n  return(sim)\n}\n",
    "created" : 1410899149654.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2151210129",
    "id" : "774AE6A7",
    "lastKnownWriteTime" : 1410899258,
    "path" : "~/Documents/rgadget/trunk/stock.R",
    "project_path" : "trunk/stock.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}