{
    "contents" : "\n##' For each prey an upper limit needs to be set on the total amount\n##' consumed by all predators so as not to obtain more consumption than\n##' available biomass.  Consumption is limited to 95\\% (\\eqn{R_M}) of the\n##' available biomass. This is implemented by scaling target consumption by all\n##' predators. Let \\eqn{R_{prey}(l)}{R_prey(l)} be the Ratio consumed and\n##' \\eqn{R_M} be the maximum ratio consumed then\n##' \\deqn{R_{prey}(l)=\\frac{\\sum_{pred}\\sum_{L}C_{pred,prey}(L,l)}{N_{prey}(l)W_{prey}(l)}}\n##' If \\eqn{R_{prey}(l)>R_M}{R_prey(l)>R_M} consumption is adjusted as follows\n##' \\deqn{C_{pred,prey}(L,l)=R_MN_{prey}(l)W_{prey}(l)\\frac{C_{pred,prey}(L,l)}{\\sum_{pred}C_{pred,prey}(L,l)}}\n##' @title Adjust for overconsumption \n##' @param C is the commercial catch of prey\n##' @param S is the survey catch of prey\n##' @param E is the consumption of prey by predator\n##' @param N is the total number of prey\n##' @param opt gadget options list\n##' @return a list with adjusted catches/consumption for C, S and E.\nadjustconsumption <- function(C,\n                              S=NULL,\n                              E=NULL,\n                              N,\n                              maxratioconsumed,\n                              numofareas)\n{\n  if(is.null(S))\n    S <- array(0,dim(C))\n  if(is.null(E))\n    E <- array(0,dim(C))\n  ## Nasty hack\n  if(numofareas==1){\n    dim(C) <- c(1,dim(C))\n    dim(S) <- c(1,dim(S))\n    dim(E) <- c(1,dim(E))\n    dim(N) <- c(1,dim(N))\n  }\n  ratio <- apply(C+S+E,c(1,2),sum)/apply(N,c(1,2),sum)\n  ratio <- ifelse(is.infinite(ratio)|is.nan(ratio),0,ratio)\n  index <- ratio > maxratioconsumed\n  if(sum(index)>0)\n    print(\"Warning - understocking has occured\")\n  index2 <- array(index,c(dim(index),dim(C)[3]))\n  C[index2] <- (maxratioconsumed/ratio[index])*C[index2]\n  S[index2] <- (maxratioconsumed/ratio[index])*S[index2]\n  E[index2] <- (maxratioconsumed/ratio[index])*E[index2]\n  return(list(C=C,S=S,E=E))\n}\n\n##' Catch is implemented to be similar to the 'Linearfleet' in Gadget. \n##' Let \\eqn{C_{fleet,prey}(l,a,t)} be the number of age \\eqn{a} prey, in\n##' lengthgroup \\eqn{l} caught at timestep \\eqn{t}, then\n##' \\deqn{C_{fleet,prey}(l,a,t) = F_{l,t}N_{prey}(l,a,t)\\Delta t}\n##' with \\eqn{F_{l,t} = S_{l}F_{y}} where \\eqn{F_y} is constant for each year, \n##' \\deqn{S_{l} = \\frac{1}{1+e^{-\\alpha-\\beta l}}}\n##' is the suitability function and \\eqn{\\alpha} and \\eqn{\\beta} are constants. ##' @title Fleet catches \n##' @param N number of prey\n##' @param timestep the timestep of the catch\n##' @param Fy fishing yield\n##' @param salpha suitability constant for the fleet\n##' @param sbeta suitability constant for the fleet\n##' @param numperyear number of catch timesteps\n##' @param numobs number of observation years\n##' @return Total catches of the fleet\ncatch <- function(N,\n                  timestep,\n                  Fy,\n                  salpha,\n                  sbeta,\n                  numperyear,\n                  numobs,\n                  l)\n{\n  #The suitability for the catch\n  temp<-suitability(params=c(salpha,sbeta,0,1),l)\n  Sl<-temp[1,]\n  Fy <- rep(Fy/numperyear,each=numobs)\n  \n  #Proportion caught each year\n  \n  Fly<-Sl*Fy[timestep]\n  if(length(dimnames(N)$area)>0)\n    Fly <- rep(Fly,each=dim(N)[1]) \n  C<-Fly*N \n  \n  return(C)\n}\n\nwhaleCatch <- function(N,NTagged,quota,salpha,sbeta){\n  MaleS <- suitability(c(salpha['Male'],sbeta['Male'],\n                       0,1),as.numeric(dimnames(N)$age))[1,]\n  FemaleS <- suitability(c(salpha['Female'],sbeta['Female'],\n                         0,1),as.numeric(dimnames(N)$age))[1,]\n  sl <- cbind(MaleS,FemaleS)\n  F <- min(1,quota/sum(sl*t(apply((N+NTagged),2:3,sum))))\n  #Proportion caught each year\n  \n  Fly<-F*sl\n#  if(length(dimnames(N)$stock)>0)\n#    Fly <- rep(Fly,each=dim(N)[1])\n#  else\n#    Fly <- rep(Fly,each=2)\n  C <- aaply(N,1,function(x) x*t(Fly))[dimnames(N)$stock,\n                                       dimnames(N)$gender,\n                                       dimnames(N)$age]\n  CT <- aaply(NTagged,1,function(x) x*t(Fly))[dimnames(N)$stock,\n                                       dimnames(N)$gender,\n                                       dimnames(N)$age]\n  \n  return(list(C=C,CT=CT))\n}\n\n##' This is a helper function for the firststep function. This defines the\n##' length distribution for each age group\n##' @title Length distribution\n##' @param mu mean length for all ages\n##' @param sigma standart deviation of length for all ages\n##' @param l lengthgroups\n##' @return a matrix of dimension length(mu) X (length(l)-1)\ndistr <- function(mu,sigma,l) {\n  fi <- (pnorm(rep(l[-1],each=length(sigma)),mu,sigma)-\n         pnorm(rep(l[-length(l)],each=length(sigma)),mu,sigma))\n  dim(fi) <- c(length(sigma),length(l)-1)\n  fi[,1] <- pnorm(rep(l[2],length(sigma)),mu,sigma)\n  fi[,length(l)-1] <- (1-pnorm(rep(l[length(l)-1],\n                                   length(sigma)),mu,sigma))\n\n  return(t(fi))\n}\n\n\n##' The following variables are used in the consumption calculations:\n##' l is Lengthgroup in prey\n##' L is Lengthgroup in predator\n##' A is Areasize\n##' H The density (biomass per area unit) of available food at\n##' which the predator can consume half maximum consumption\n##' \\eqn{\\Delta t} as Length of timestep\n##' \\eqn{M_{pred}(L)} as Maximum consumption\n##' \\eqn{\\psi_{pred}(L)} as Fraction of \\eqn{M_{pred}} consumed\n##' N_{pred}(L) as Number of predator \\eqn{pred} in lengthgroup $L\n##' N_{prey}(l) as Number of prey \\eqn{prey} in lengthgroup l\n##' W_{prey}(l) as The mean weight of prey of length l\n##' S_{pred,prey}(L,l) as Suitability of prey at length l for pred at length L\n##' C_{prey,pred}(L,L) as Total weight predator of length L consumes of prey of length $l$\n##' The formula for the consumption is as follows:\n##' \\deqn{C_{pred,prey}(L,l)=N_{pred}(L)M_{pred}(L)\\Psi_{pred}(L)\\frac{F_{pred,prey}(L,l)}{\\sum_{l,prey}F_{pred,prey}(L,l)}}\n##' \\deqn{=N_{pred}(L)M_{pred}(L)\\frac{\\sum_{l,prey}F_{pred,prey}(L,l)}{\\sum_{l,prey}F_{pred,prey}(L,l)+HA}\\frac{F_{pred,prey}(L,l)}{\\sum_{l,prey}F_{pred,prey}(L,l)}}\n##' \\deqn{=N_{pred}(L)M_{pred}(L)\\frac{F_{pred,prey}(L,l)}{\\sum_{l,prey}F_{pred,prey}(L,l)+HA}}\n##' where\n##' \\deqn{F_{pred,prey}(L,l) =S_{pred,prey}(L,l)N_{prey}(l)W_{prey}(l)}\n##' \\deqn{ M_{pred}(L) =m_0e^{(m_1T-m_2T^3)}L_{pred}^{m_4}\\Delta t}\n##' The suitability function for predation used in the \\R model is:\n##' \\deqn{S_{pred,prey}(L,l) = \\frac{\\delta}{1+e^{-\\alpha-\\beta l-\\gamma L}}}\n##' With one predator, one prey and otherfood the equation becomes:\n##' \\deqn{C_{L,l}=N_{L}M_{L}\\Psi_{L}\\frac{F_{L,l}}{\\sum_lF_{L,l}+OA}}\n##' \\deqn{=N_{L}M_{L}\\frac{F_{L,l}}{\\sum_lF_{L,l}+OA+HA}}\n##' where O is the density of otherfood.\n##' @title Eat\n##' @param PreyInArea Number of prey items in the area\n##' @param PredInArea Number of predator items in the area\n##' @param step the timestep, that is the time of the year\n##' @param opt gadget options list\n##' @return The total unadjusted consumption of the predator on the prey\neat <- function(PreyInArea,PredInArea,step,opt){  \n  preydim <- dim(PreyInArea)\n  preddim <- dim(PredInArea)\n  if(preydim[2]!=preddim[2]){\n    print(\"Error - the number of lengthgroups is not the same for predation\")\n  }else{\n    numoflgroups <- preydim[2]\n  }\n  ## The amount eaten\n  Eat<-array(0,preydim[1:3])\n  ## The suitability for the predation\n  Spred<-suitability(params=c(opt$spalpha,opt$spbeta,opt$spgamma,opt$spdelta),opt$lt,opt$lt)\n  ## Food = S(L,l)*N_l\n  Food<-array(0,c(numoflgroups,opt$numoflgroups,preydim[3]))\n  \n  for(area in 1:opt$numofareas){\n    Prey <- PreyInArea[area,,,step]\n    Pred <- PredInArea[area,,,step]\n  # F_{Llat}\n    for(i in 1:preydim[3])\n      Food[,,i]<-t(Spred)*Prey[,i]*opt$w\n  # loop through predators lengths\n    predsum <- apply(Pred,1,sum)*opt$maxConsumption\n    foodsum <- apply(Food,2,sum)\n    other <- opt$H*opt$lengthoftimesteps+opt$otherfood[step]*opt$otherfrac\n    for(j in 1:numoflgroups){\n      Eat[area,,] <- Eat[area,,] +\n        predsum[j]*Food[,j,]/(foodsum[j] + other*opt$areasize)\n    }\n\n    Eat[area,,] <- Eat[area,,]/opt$w\n  }\n  return(Eat)\n}\n\n\n##' The simulation is started with an initial population, the age of which\n##' ranges from the minimum age of the immature stock to the maximum age\n##' of the mature stock. This population is calculated as follows:\n##' Let \\eqn{n_{a}} be the number of age \\eqn{a} individuals in the first\n##' timestep, \\eqn{\\mu_{a}} the mean length at age \\eqn{a} and \\eqn{\\sigma_{a}}\n##' the standard deviation of length at age \\eqn{a}. For the minimum age\n##' (representing recruitment) see the recruitment function. For a given\n##' constant mortality \\eqn{Z_{0}} we get\n##' \\deqn{n_{a} = n_{a-1}e^{-Z_{0}}}\n##' to calculate the number at age for all \\eqn{a}.\n##' The number in lengthgroup $i$ at age $a$ in timestep 1 can then be\n##' calculated from:\n##' \\deqn{N_{i,a,1} = n_a\\left(\\Phi\\left(\\frac{l_{i+1}-\\mu_a}{\\sigma_a}\\right)-\\Phi\\left(\\frac{l_{i}-\\mu_a}{\\sigma_a}\\right)\\right)}{N_{i,a,1} = n_a (Phi(l_{i+1}-mu_a)/sigma_a)-Phi(l_{i}-\\mu_a)/sigma_a))}\n##' where \\eqn{l_{i}} and \\eqn{l_{i+1}} are the endpoints of lengthgroup \\eqn{i},\n##' \\eqn{N_{l,a,t}} is the number at age \\eqn{a} in lengthgroup \\eqn{l} at\n##' timestep \\eqn{t} and \\eqn{\\Phi}{Phi} is the probability function for Normal\n##' distribution. \n##' NB: in Gadget (which is programmed in C++) the value of \\eqn{\\Phi}{Phi} is\n##' approximated whereas R uses integration. To ensure\n##' compatibility between the models, the initial population for Gadget is\n##' entered directly from the initial population file rather than\n##' calculated from a Normal distribution. While this is an option\n##' within Gadget, it is not the standard method.\n##' @title The first timestep\n##' @param n Number of age 1 individuals\n##' @param mu Vector of mean length per age.\n##' @param sigma Vector of standard deviation of length per age.\n##' @param l Vector of length groups\n##' @param z Natural mortality per age\n##' @param numofareas Number of areas\n##' @param probarea Vector of proportions living in an area. \n##' @param minage Minimum age of the species.\n##' @param maxage Maximum age of the species.\n##' @return matrix with initial distribution\nfirststep <- function(n,\n                      mu,\n                      sigma,\n                      l,\n                      z,\n                      numofareas,\n                      probarea,\n                      minage,\n                      maxage\n                      ) {\n  minlen <- min(l)\n  maxlen <- max(l)\n  numoflgroups <- length(l)-1\n  num.agegroup <- n[1]*exp(-(minage:maxage-1)*z)\n  \n  if((maxage - minage +1)!=length(sigma)) {\n    stop(\"Error - the number of age groups for sigma doesnt match the maximum age\")\n   # return('Error')\n  }\n    \n  temp <- distr(mu,sigma,l)*rep(num.agegroup,each=numoflgroups)\n#  if(minage>1)\n#    temp[,1:minage] <- 0 \n  # assign the distribution to areas according to the probability of being in\n  # that area\n  if(length(probarea)!=numofareas){\n    stop(\"Error - the area probabilities do not match the number of areas\")\n  }\n  initial.distribution <- array(rep(temp,each=numofareas),\n                                c(numofareas,dim(temp)))*probarea\n  dimnames(initial.distribution) <- list(area=1:numofareas,\n                                         length=minlen:(maxlen-1),\n                                         age=minage:maxage\n                                         )\n  \n  return(initial.distribution)\n}\n\n\n\n##' Growth is according to a von Bertalanffy equation \n##' \\deqn{\\mu_{a} = L_{\\infty}(1-e^{-\\kappa a})}\n##' with the lengthvbsimple growth function from Gadget implemented.\n##' For a fish of age a and length l, mean length growth \\eqn{\\Delta L} is\n##' then calculated as:\n##' \\deqn{\\Delta L =L_{\\infty}(1 - \\frac{l}{L_{\\infty}})(1 - e^{-\\kappa \\Delta t})}\\deqn{Delta L =L_{infty}(1 - l/L_{infty})(1 - e^{-kappa Delta t})}\n##' The length distribution is updated using the beta-binomial\n##' distribution, ie the probability of growing x lengthgroups, given\n##' maximum lengthgroupgrowth n, is\n##' \\deqn{P[X = x] =  \\frac{\\Gamma(n+1)}{\\Gamma(n-x+1)\\Gamma(x+1)} \\frac{\\Gamma(\\alpha + \\beta)}{\\Gamma(n+\\alpha+\\beta)} \\frac{\\Gamma(n-x+\\beta)}{\\Gamma(\\beta)} \\frac{\\Gamma(x+a)}{\\Gamma(\\alpha)}}\n##' with \\eqn{\\alpha = \\frac{\\beta\\Delta L}{n-\\Delta L}} to preserve the mean\n##' lengthgrowth according to the equation equation above. NB: the\n##' expected value of \\eqn{\\Delta L} should be taken into consideration when\n##' fixing n. \n##' Let \\eqn{G = [g_{ij}]} be the length updating matrix where \\eqn{g_{ij}} is the\n##' probability of growing from lengthgroup i to lengthgroup j\n##' obtained from the equation above.\n##' \\deqn{N_{l,a+1,t+\\Delta t} = \\sum_{l'\\leq l}g_{l'l}N_{l,a,t}}\n##' with \\eqn{N_{l,a,t}} as described for the initial population for a >\n##' min a .\n##' @title Growth probability\n##' @param lt Vector of midpoints for the length groups.\n##' @param beta Beta for the Von Bertanlanffy curve \n##' @param lsup \\eqn{l_\\infty}{l_infty} for the Von Bertanlanffy.\n##' @param k \\eqn{\\kappa}{kappa} for the Von Bertanlanffy.\n##' @param dt Length of the time interval.\n##' @param lengthgrouplen length of the lengthgroups.\n##' @param binn is the maximum updating length.\n##' @return a matrix where the index (j,i) repsents the probability of going\n##' lengthgroup i to lengthgroup j\ngrowthprob <-function(lt,\n                      beta,\n                      lsup,\n                      k,\n                      dt,\n                      lengthgrouplen,\n                      binn)\n{\n  \n  prob <- function(alpha,beta,x){\n    na <- length(alpha)\n    n <- length(x) - 1\n    alpha <- rep(alpha,n + 1)\n    x <- rep(x,each=na)\n    ## Create a probability matrix where the columns represent the\n    ## probability of growing x lengthgroups for each lengthgroup\n    ## length group jumps are distributed according to a beta-binomial\n    ## distribution\n    val <- exp(lgamma(n + 1)+\n               lgamma(alpha + beta) +\n               lgamma(n - x + beta) +\n               lgamma(x + alpha) -\n               lgamma(n - x + 1) -\n               lgamma(x + 1) -\n               lgamma(n + alpha + beta) -\n               lgamma(beta) -\n               lgamma(alpha))\n    dim(val) <- c(na,n + 1)\n    growth.matrix <- array(0,c(na,na))\n    for(lg in 1:na){\n      if(lg == na){\n        growth.matrix[na,na] <- 1\n      } else if(lg + n > na){\n        growth.matrix[lg,lg:(na-1)] <- val[lg,1:(na - lg )]\n        growth.matrix[lg,na] <- sum(val[lg,(na - lg + 1):(n + 1)])\n      } else {\n        growth.matrix[lg,lg:(n + lg)] <- val[lg,]\n      }\n    }\n    return(growth.matrix)\n  }\n  ## dmu[i] is the mean growth in lengthgroup i \n  dmu <- lsup*(1-lt/lsup)*(1-exp(-k*dt))\n\n  ## if growth>maxgrowth assume that growth is a bit smaller than maxgrowth\n  dmu[dmu/lengthgrouplen >= binn] <- binn-0.1\n\n  ## if growth is negative assume no growth\n  dmu[dmu < 0] <- 0\n  \n  alpha <- (beta*dmu/lengthgrouplen)/(binn-dmu/lengthgrouplen)\n  ## possible length growth\n  length.growth <- 0:binn\n  \n  return(prob(alpha,beta,length.growth))\n}\n\n##' If more than one area is defined the user can define migration\n##' between the areas. The migration procedure is the same as in MULTSPEC. \n##' The migration is defined and takes place in every timestep and it is\n##' assumed to be constant for all years. This means that the porportion that\n##' migrates from area i to j can be different between different timesteps\n##' (seasons) but they are fixed between observations (years). Migration at\n##' timestep t is defined by the user as an \\eqn{n\\times n}{nxn} transition\n##' matrix P_t := [p_{ij}] where p_{ij} is the proportion moving from area j\n##' to area i, ignoring other processes. For P to be a transition matrix\n##' \\eqn{\\sum_ip_{ij} = 1}{sum_i p_ij = 1}, for each j. The vector of abundance\n##' for all areas at time t is therefore:\n##' \\deqn{\\mathbf{N_t} = P_t \\mathbf{N_{t-1}}}{N_t = P_t N_{t-1}}\n##' In a two area example this would mean that if N_{1,t-1} is a matrix\n##' containing the abundance in numbers in area 1 at timestep t before\n##' migration and N_{2,t-1} is the same number for area 2, the numbers after\n##' migration will be\n##' \\deqn{N_{1,t} = p_{11}\\cdot N_{1,t-1} + p_{12}\\cdot N_{2,t-1} }\n##' \\deqn{N_{2,t} = p_{21}\\cdot N_{2,t-1}+ p_{22}\\cdot N_{2,t-1} }\n##' @title Migrate\n##' @param N An array containing substock abundance by area (first dimension) and other variables\n##' @param M an array with migration matricies\n##' @return the migrated substock abundance array\n##' @author Bjarki Þór Elvarsson\nmigrate <- function(N,M){\n  numofareas <- dim(N)[1]\n  for(area in 1:numofareas){\n    N[area,,] <- apply(M[area,]*N,c(2,3),sum)\n  }\n  return(N)\n}\n\n\n##' The timestep (or timesteps) on which recruitment takes place is\n##' defined by the user. \n##' Given \\eqn{n_{t}} recruits, at timestep t, with mean length\n##' \\eqn{\\mu}{mu} and\n##' standard deviation of length \\eqn{\\sigma}{sigma}, the number of recruits in\n##' lengthgroup i is calculated by:\n##' \\deqn{N_{i,1,t} = n_t(\\Phi(\\frac{l_{i+1}-\\mu}{\\sigma})-\\Phi(\\frac{l_{i}-\\mu}{\\sigma}))}\n##' As for the initial population, the number of recruits in each length\n##' groups is given in the recruit input file. \n##' @title Recruitment\n##' @param n Number of recruited individuals\n##' @param mu Vector of mean length per age.\n##' @param sigma Vector of standard deviation of length per age.\n##' @param l Vector of length groups\n##' @param numofareas Number of areas\n##' @param probarea Vector of proportions living in an area. \n##' @param numobs Number of years.\n##' @param numoftimesteps Number of observations per year.\n##' @return Recruits by area, length, time\nrecruits <- function(n,mu,sigma,\n                     l,numofareas,probarea,\n                     numobs,numoftimesteps)\n{\n  \n  Temp <- distr(mu,sigma,l)%*%t(n)\n  rec <- array(rep(Temp,each=2),c(numofareas,dim(Temp)))*probarea\n  dimnames(rec) <- list(area = 1:numofareas,\n                        length = min(l):(max(l)-1),\n                        time=paste(sprintf('Year_%s',rep(1:numobs,\n                                each=numoftimesteps)\n                                ),\n                                sprintf('Step_%s',rep(1:numoftimesteps,\n                                                      numobs)),\n                                sep='_'))\n  return(rec)\n}\n\n\n\n##' The suitability function for predation used in the R model is:\n##' \\deqn{S_{pred,prey}(L,l) = \\frac{\\delta}{1+e^{-\\alpha-\\beta l-\\gamma L}}}{S_{pred,prey}(L,l) = \\frac{delta}{1+e^{-alpha-beta l-gamma L}}}\n##' With one predator, one prey and otherfood the equation becomes:\n##' \\deqn{C_{L,l}=N_{L}M_{L}\\Psi_{L}\\frac{F_{L,l}}{\\sum_lF_{L,l}+OA}}\n##' \\deqn{=N_{L}M_{L}\\frac{F_{L,l}}{\\sum_lF_{L,l}+OA+HA}}\n##' where $O$ is the density of otherfood.\n##' @title Prey suitability\n##' @param salpha \\eqn{\\alpha}{alpha} for the suitability function.\n##' @param sbeta \\eqn{\\beta}{beta} for the suitability function.\n##' @param sgamma \\eqn{\\gamma}{gamma} for the suitability function.\n##' @param sdelta \\eqn{\\delta}{delta} for the suitability function.\n##' @param l prey length group(s)\n##' @param L predator length group(s)\n##' @return matrix of suitabilities, columns prey length, lines predator length\nsuitability <- function(params,\n                        l,\n                        L=c(0),\n                        type = 'exponential',\n                        to.data.frame = FALSE,\n                        normalize = FALSE)\n{\n\n  if(tolower(type) == 'andersenfleet'){\n    type <- 'andersen'\n    L <- params[6]\n  }\n  \n  if(tolower(type) == 'constant'){\n    S <- array(params[1],c(length(L),length(l)))\n\n  } else if(tolower(type) == 'straightline') {\n    S <- array(rep(l*params[1] + params[2],each = length(L)),\n               c(length(L),length(l)))\n\n  } else if(tolower(type) == 'exponential'){\n    S <- array(params[4]/(1+exp(-(params[1]+params[2]*rep(l,each=length(L))+\n                               params[3]*rep(L,length(l))))),\n               c(length(L),length(l)))\n    \n  } else if(tolower(type) == 'exponentiall50'){\n    S <- array(rep(1/(1+exp(-params[1]*(l - params[2]))),each = length(L)),\n               c(length(L),length(l)))\n\n  } else if(tolower(type) == 'richards') {\n    S <- array(params[4]/(1+exp(-(params[1]+params[2]*rep(l,each=length(L))+\n                                  params[3]*rep(L,length(l))))),\n               c(length(L),length(l)))^(1/params[5])\n\n  } else if(tolower(type) == 'andersen') {\n    l.tmp <- rep(l,each=length(L))\n    L.tmp <- rep(L,length(l))\n    if(L==0)\n      L.tmp <- median(l.tmp)\n    \n    S <- array(params[1] + params[3]*\n               ifelse(log(L.tmp/l.tmp) < params[2],\n                      exp(-(log(L.tmp/l.tmp)-params[2])^2/params[5]),\n                      exp(-(log(L.tmp/l.tmp)-params[2])^2/params[4])),\n               c(length(L),length(l)))\n    \n  } else if(tolower(type) == 'gamma'){\n\n    S <- array(rep((l/((params[1] - 1)*params[2]*params[3]))^(params[1] -1) *\n                   exp(params[1] - 1 - 1/(params[2]*params[3])),\n                   each = length(L)),\n               c(length(L),length(l)))\n  } else {\n    stop(sprintf('Error in suitability -- %s not defined',type))\n  }\n  if(to.data.frame){\n    dimnames(S) <- list(L=L,l=l)\n    S <- as.data.frame.table(S,responseName = 'suit')\n    if(normalize)\n      S$suit <- S$suit/max(S$suit)\n    S$L <- as.numeric(S$L)\n    S$l <- as.numeric(S$l)\n  } else {\n    dimnames(S) <- list(sprintf('Pred_length_%s',L),\n                        sprintf('Prey_length_%s',l))\n  }\n  return(S)\n}\n\n\noverlap <- function(Abundance,mixing){\n  stock.num <- aaply(Abundance,c(1,3),\n                     function(x) sum(x))[dimnames(Abundance)$stock,\n                                         dimnames(Abundance)$age]\n  for(stock in dimnames(Abundance)$stock)\n    Abundance[stock,,] <- t(stock.num[stock,]%o%mixing[,stock])\n  return(Abundance)\n}\n\ndispersion <- function(Abundance,dispersion){\n  tmp <- Abundance\n  Abundance <- 0*tmp\n  for(from in dimnames(Abundance)$stock){\n    for(to in dimnames(Abundance)$stock){\n      Abundance[to,,] <- Abundance[to,,] +\n        tmp[from,,]*dispersion[from,to]\n    }\n  }\n  return(Abundance)\n}\n\ninit.pop <- function(init.abund,M,maxage,probarea){\n  x <- init.abund*(1-exp(-M))/(1-exp(-M*(maxage+1)))\n  array(rep(x*exp(-M*(0:maxage)),\n            each=length(probarea))*probarea,\n        c(length(probarea),maxage+1))\n}\n\n#tag.experiment <- function(Abundance,tag.number){\n#  tag.number*Abundance/sum(Abundance)\n#}\n\nBirths <- function(B,N,A,z,K){\n  b <- array(0,c(dim(N)[1],2,dim(N)[2]),\n             dimnames=list(stock=dimnames(N)$stock,\n               gender=c('Male','Female'),\n               area=dimnames(N)$area))\n  for(stock in dimnames(N)$stock){\n    b[stock,'Male',] <- B*N[stock,]*(1+A*(1-(sum(N[stock,])/K[stock])^z))\n    b[stock,'Female',] <- B*N[stock,]*(1+A*(1-(sum(N[stock,])/K[stock])^z))\n  }\n  return(b)\n}\n",
    "created" : 1410899341599.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1373997540",
    "id" : "F73A3DD4",
    "lastKnownWriteTime" : 1410899544,
    "path" : "~/Documents/rgadget/trunk/function.R",
    "project_path" : "trunk/function.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}